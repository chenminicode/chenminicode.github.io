{
  "hash": "120e7e5fa007c661e07125030918cc17",
  "result": {
    "markdown": "---\ntitle: Python中的几个魔法方法\nauthor: metseq\ndate: '2022-11-31'\ncategories:\n  - Python\ntoc: true\nnumber-sections: true\n---\n\n# 类和对象的`__dict__`属性\n\n## 对象的`__dict__`属性\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass Point():\n    '''Create a Point'''\n    my_name = 'A Point'\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\np = Point(3, 4)\np.__dict__\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n{'x': 3, 'y': 4}\n```\n:::\n:::\n\n\n对象的`__dict__`属性就是一个字典，这个字典的键是对象的属性，值就是对应属性的值。\n\n当给对象属性复制的时候，就是修改`__dict__`字典。\n\n## 类的`__dict__`属性\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nPoint.__dict__\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nmappingproxy({'__module__': '__main__',\n              '__doc__': 'Create a Point',\n              'my_name': 'A Point',\n              '__init__': <function __main__.Point.__init__(self, x, y)>,\n              '__dict__': <attribute '__dict__' of 'Point' objects>,\n              '__weakref__': <attribute '__weakref__' of 'Point' objects>})\n```\n:::\n:::\n\n\n可以看到，`Point`类的`__dict__`属性包括了：\n- 类的文档`__doc__`\n- 类中定义变量，比如这里的`my_name`\n- 类的方法\n- 其他一些不知道什么的东西😓\n\n# 类的`__repr__`和`__str__`方法\n\n## `__repr__`方法\n\n直接输出`p`时，会显示一堆没用的东西\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\np\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n<__main__.Point at 0x1b97777e6b0>\n```\n:::\n:::\n\n\n我们想显示关于`Point`的有用信息，这时`__repr__`方法就派上用场了\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return \"Point(x=%r, y=%r)\" % (self.x, self.y)\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\np = Point(3, 4)\np\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nPoint(x=3, y=4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __setattr__(self, name, value):\n        print(f'set attr {name} to float({value})')\n        self.__dict__[name] = float(value)\n    \n    def __repr__(self):\n        return \"Point(x=%r, y=%r)\" % (self.x, self.y)\n```\n:::\n\n\n## `__str__`方法\n\n`__str__`方法和`__repr__`方法好像都是用字符表示对象的，有什么区别呢？\n\n[stackoverflow](https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr)有一个回答说：\n\n- `__repr__`显示的信息需要避免歧义\n- `__str__`显示的信息注重可读性，方便理解\n- `__str__`使用了`__repr`\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nstr(p)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n'Point(x=3, y=4)'\n```\n:::\n:::\n\n\n在`Point`中如果没有重写`__str__`方法，会调用`__repr__`输出的结果\n\n如果在`Point`中重写了`__str__`方法，就会输出`__str__`调用的结果。\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return \"Point(x=%r, y=%r)\" % (self.x, self.y)\n    \n    def __str__(self):\n        return f'Just a normal 2d point({self.x}, {self.y})'\n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\np = Point(3, 4)\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\np\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nPoint(x=3, y=4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nrepr(p)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n'Point(x=3, y=4)'\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nprint(p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJust a normal 2d point(3, 4)\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nstr(p)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n'Just a normal 2d point(3, 4)'\n```\n:::\n:::\n\n\n# 类的`__setattr__`方法\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\np = Point('3', '4')\np\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nPoint(x='3', y='4')\n```\n:::\n:::\n\n\n想在初始化Point的时候，把x，y属性转变成float类型，`__setattr__`方法就能用上了\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nclass Point():\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __setattr__(self, name, value):\n        self.__dict__[name] = float(value)\n    \n    def __repr__(self):\n        return \"Point(x=%r, y=%r)\" % (self.x, self.y)\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\np = Point('3', '4')\np\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nPoint(x=3.0, y=4.0)\n```\n:::\n:::\n\n\n```python\np.__dict__\n```\n\np的x和y属性都已经是float类型了，这是怎么做到的呢？\n\n在类的`__init__`函数中，`self.x = `x这一句，`self.x`的值设为`x`，\n\n当遇到这种`对象.属性 = 值`的时候，如果重写了`__setattr__`方法，就会调用`__setattr__`方法，\n\n也就是说当遇到`对象.属性 = 值`，相当于调用了`__setattr__(对象, 属性, 值)`\n\n在这里相当于`__setattr__(self, 'x', x)`，在`__setattr__`函数里修改了`self.__dict__['x'] = float(value)`\n\n`__setattr__`函数里面可以做你想做的任何事情，不仅仅是改变默认的属性赋值操作\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nclass Point():\n    def __init__(self, x, y):\n        self._modules = {}\n        self.x = x\n        self.y = y\n    \n    def __setattr__(self, name, value):\n        if not name.startswith('_'):\n            self._modules[name] = value\n            print(f'add {name}:{value} to _module')\n        print(f'set {name} to {value}')\n        super().__setattr__(name, value)\n        \n    def __repr__(self):\n        return \"Point(x=%r, y=%r)\" % (self.x, self.y)\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\np = Point(3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nset _modules to {}\nadd x:3 to _module\nset x to 3\nadd y:4 to _module\nset y to 4\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\np._modules\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n{'x': 3, 'y': 4}\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}