{
  "hash": "7c469a00144e4156792fe9a781db75bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R语言里的离散型随机变量分布函数\"\nauthor: \"metseq\"\ndate: \"2024-03-24\"\ncategories: [R]\ntoc: true\nnumber-sections: true\nexecute:\n  output: true\n---\n\n\n随机变量分为离散型随机变量和连续性随机变量两种。这里仅讨论离散型随机变量，他们的定义，例子和在R里怎么调用。\n\n# 伯努利分布\n\n伯努利随机变量是最简单的了，就是投掷一枚硬币，是正面朝上还是反面朝上。比如记正面朝上为1，反面朝上为0。\n\n在R里，生成伯努旅随机变量的函数如下：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 这里相当于投了15次硬币\nrbinom(n = 15, prob = 0.5, size = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 1 0 1 1 0 1 1 1 0 0 1 0 1 1\n```\n\n\n:::\n:::\n\n\n查看rbionm函数的帮助，帮助里有4个函数：\n\n-   dbinom：概率密度函数\n\n-   pbinom：概率质量函数\n\n-   qbinom：分位函数\n\n-   rbinom：随机变量生成函数（上面见过了）\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbinom(0:1, size = 1, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5 0.5\n```\n\n\n:::\n:::\n\n\n就是取0，1的概率都是0.5。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbinom(0:1, size = 1, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5 1.0\n```\n\n\n:::\n:::\n\n\n取小于等于0的概率是0.5，小于等于1的概率是1。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqbinom(c(0.5, 1), size = 1, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1\n```\n\n\n:::\n:::\n\n\n相当于pbionm的逆函数了，提供概率质量函数的概率，给出对应概率的取值。\n\n其他函数也有这4个函数组合，同样的前缀。类似的用法，只是需要提供对应分布的参数。\n\n# 二项分布\n\n二项分布是伯努利分布的扩展，伯努旅分布是投掷1次硬币，二项分布是投掷多次硬币，看正面朝上的次数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 每一个值表示投掷10次硬币，有多少次正面朝上。有20个值时这个实验重复了20次\nrbinom(20, size = 10, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 2 5 6 2 3 6 7 6 5 8 6 2 3 2 4 4 5 2 5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndbinom(0:10, size = 10, prob = 0.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.0009765625 0.0097656250 0.0439453125 0.1171875000 0.2050781250\n [6] 0.2460937500 0.2050781250 0.1171875000 0.0439453125 0.0097656250\n[11] 0.0009765625\n```\n\n\n:::\n\n```{.r .cell-code}\nbarplot(dbinom(0:10, size = 10, prob = 0.5), names.arg = 0:10, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n果然5次正面朝上的概率是最高的。\n\n# 多项分布\n\n多项分布是二项分布的扩展，二项分布是重复伯努利实验，伯努利实验每次只有2个结果。多项分布相当于伯努利实验每次有多个结果。\n\n比如每次投掷一个6面的骰子🎲，重复10次，统计1：6出现次数的分布就是服从多项分布的。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npvec = rep(1/6, 6)\nrmultinom(5, size = 10, prob = pvec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    1    1    2\n[2,]    3    1    2    3    1\n[3,]    2    1    0    3    3\n[4,]    1    1    5    0    1\n[5,]    3    5    1    1    1\n[6,]    0    0    1    2    2\n```\n\n\n:::\n:::\n\n\n每一列是一次实验（投掷10次骰子）的结果统计\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmultinom(c(2, 2, 2, 2, 2, 0), size = 10, prob = pvec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.001875429\n```\n\n\n:::\n:::\n\n\n# 泊松分布\n\n我开始认识泊松分布是的时候是它的公式，有点晕，不知所云。后来知道泊松分布其实就是特殊情况下的二项分布的近似，泊松分布的公式也是这么推导出来的。我们看看是什么情况。\n\n《[Modern Statistics for Modern Biology](https://web.stanford.edu/class/bios221/book/)》里有一个很好的例子。HIV病毒每复制一次，每个碱基突变的概率是0.0005，HIV基因组大约是10000bp，那么HIV复制一次，有多少个碱基发生突变呢？这个就是符合速率为0.0005 x 10000 = 5泊松分布。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrpois(20, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 6 4 6 8 6 6 6 9 4 5 6 5 5 7 4 5 5 6 6 8\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(dpois(0:10, 5), names.arg = 0:10, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nHIV复制一次，相当于10000个碱基每个复制一次，每个碱基突变的概率是0.0005。相当于投掷10000次硬币，正面朝上的概率是0.0005，最后有多少次正面朝上！\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(dbinom(0:10, size = 10000, prob = 0.0005), names.arg = 0:10, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n上面两个图是一致的，不信，再看看具体概率：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndpois(0:10, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.006737947 0.033689735 0.084224337 0.140373896 0.175467370 0.175467370\n [7] 0.146222808 0.104444863 0.065278039 0.036265577 0.018132789\n```\n\n\n:::\n\n```{.r .cell-code}\ndbinom(0:10, size = 10000, prob = 0.0005)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.006729527 0.033664467 0.084194850 0.140366868 0.175493694 0.175511252\n [7] 0.146259377 0.104460531 0.065274768 0.036252875 0.018119183\n```\n\n\n:::\n:::\n\n\n::: callout-important\n当二项分布实验次数n很大，p很小时，可以近似为速率参数为np的泊松分布。\n:::\n\n# 负二项分布\n\n我们先看一个例子，有一罐鱼皮花生，其中吃到发霉花生的概率1/10，如果我想吃5个好花生，总共吃的发霉花生个数就是符合负二项分布（其实我不会吃的，会吐掉，然后漱口）。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnbinom(10, size = 5, prob = 9/10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 1 0 0 3 0 0 1 0 0\n```\n\n\n:::\n:::\n\n\n这里我做了10次实验，看来大概率是吃到1-2个发霉花生。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(dnbinom(0:5, size = 5, prob = 9/10), names.arg = 0:5, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n# 几何分布\n\n几何分布也是二项分布的延伸。还是举花生的例子，吃到发霉发生的概率是1/10，那么我第一次吃到发霉花生时，总共吃了几个好花生，就是符合几何分布的。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrgeom(10, prob = 1/10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 14  1  1  3  2  1  1  3 31 20\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndgeom(0:3,  prob = 1/10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1000 0.0900 0.0810 0.0729\n```\n\n\n:::\n:::\n\n\n吃到0个好花生的概率是0.1，1个好花生的概率是0.9 x 0.1 = 0.09，2个好花生的概率是0.9 x 0.9 x 0.1 = 0.081。\n\n# 超几何分布\n\n超几何分布应该在基因富集分析的应用而鼎鼎有名。\n\n其实大家高中就学过了。有20个球，其中14个是红球，6个是黑球，随机取5个球不放回，取到的红球的数目就是符合超几何分布。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrhyper(0:5, 14, 6, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 3 5 4 4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(dhyper(0:5, 14, 6, 5), names.arg = 0:5, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}